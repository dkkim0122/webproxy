
**01. 네트워크**
===

**용어 정리**
---

- 호스트
    
    > 인터넷 네트워크에 접속되고 다른 인터넷 호스트와 통신할 수 있는 **컴퓨터**. 인터넷 네트워크에서 호스트는 인터넷 이름과 주소로 식별된다.
    > 
- 패킷
    
    > 호스트와 네트워크 사이의 한 트랜젝션에 대한 제어 정보 및 **데이터 블록**. 인터넷 네트워크 상에서 전달되는 데이터들의 묶음이라고 보면 될 듯.
    > 
    
    패킷은 **소스**에서 **대상**으로 전송된다. 통신 네트워크에서 보면 **호스트는 패킷의 소스이면서 대상이다**.
    
- 포트
    
    > 각 프로토콜의 데이터가 통하는 논리적 통로이다. 각 **프로토콜의 데이터가** 컴퓨터 내부의 **논리적 포트에 따라 흐른다.** IP 내에서 프로세스 구분을 하기 위해 사용된다.
    > 
    
    하드웨어 상의 포트는 컴퓨터가 각종 신호를 받아들이고 내보낼 수 있도록 연결할 수 있는 연결단자를 뜻한다.
    
- 프로토콜
    
    > 컴퓨터들 간의 원활한 통신을 위해 지키기로 약속한 규칙 세트.
    > 

<br>

**클라이언트-서버 프로그래밍 모델**
===

> 모든 네트워크 응용 프로그램은 클라이언트-서버 모델에 기초하고 있다.
> 

💡 클라이언트와 서버는 컴퓨터나 호스트가 아니다. 단지 **프로세스이다.** 따라서 한 호스트는 여러 클라이언트와 서버를 동시에 실행할 수도 있고, 하나의 클라이언트나 서버가 다른 호스트에서 실행될 수도 있다.


- **클라이언트** : 서비스를 사용하는 사용자
- **서버** : 서비스를 제공하는 컴퓨터 또는 프로세스. 여러 **리소스(하드웨어, 소프트웨어 데이터베이스 등)들을 관리**한다.
- **트랜젝션** : 클라이언트와 서버는 서로 데이터를 교환하거나 이에 관련한 작업을 수행한다. 이를 트랜젝션이라 하고, 클라이언트-서버 모델에서 기본적인 연산이 된다.

<p align = 'center'>
<img src = "https://user-images.githubusercontent.com/93521799/146636857-b09fce19-16e2-4d8f-94bd-db6e93a20528.png">
</p>
<p align = 'center'>
<em>클라이언트-서버 프로그래밍 모델.</em>
</p>


- 작업 순서
    - 클라이언트가 서비스를 필요로 할 때 서버에 **한 개의 요청 request**를 보낸다.
    - 서버가 요청을 받고 이에 맞추어 **리소스들을 조작**해 요청을 수행한다.
    - 서버가 **응답**을 클라이언트에 보낸다.
    - 클라이언트가 **응답을 받아** 처리한다.

<br>

**네트워크**
===

> 둘 이상의 호스트 및 이들 사이의 연결 링크 조합을 말한다.
> 

**네트워크는 단지 또 다른 I/O 디바이스이다.**
---

> 마치 CPU가 디스크에서 파일을 읽고 쓰는 것처럼, 네트워크 상의 파일에도 똑같은 방식으로 작업한다.
> 

<p align = 'center'>
<img src = "https://user-images.githubusercontent.com/93521799/146636909-1dfbac51-ed7b-4663-8223-1b2124c557e3.png" width = "450">
</p>
<p align = 'center'>
<em></em>
</p>

<br>

**네트워크 계층 모델 : OSI 7계층**
---

[참고 : [이해하기] OSI 7계층 그리고 TCP/IP 4계층 | STEVEN J. LEE](https://www.stevenjlee.net/2020/02/09/%ec%9d%b4%ed%95%b4%ed%95%98%ea%b8%b0-osi-7%ea%b3%84%ec%b8%b5-%ea%b7%b8%eb%a6%ac%ea%b3%a0-tcp-ip-4%ea%b3%84%ec%b8%b5/)

> 컴퓨터 네트워크 프로토콜 디자인과 통신을 7개의 계층으로 나누어 설명할 수 있다.
> 

<p align = 'center'>
<img src = "https://user-images.githubusercontent.com/93521799/146638257-ea283860-7101-46f2-98b5-b5bfeb4f7955.png" width = "450">
</p>
<p align = 'center'>
<em>네트워크 계층 모델에는 OSI와 TCP/IP이 있다.</em>
</p>


💡 레벨 1 - 3은 네트워크에 특정되며 사용 중인 물리적 네트워크에 따라 달라진다. 레벨 4 - 7은 네트워크와 무관한 상위 레벨의 기능을 구성한다.


- **1레벨 : 물리 계층**
    
    > 실제 장치들을 연결하기 위해 필요한 **전기적, 물리적 세부 사항들**.
    > 
    
    물리적으로 네트워크 상에서 데이터 비트를 전송하는 계층이다.
    
    - 허브 : 각 포트에서 송신하는 모든 비트들을 모든 포트에 전송한다.
- **2레벨 : 데이터 링크 계층**
    
    > 물리 계층만으로는 신뢰성이 떨어지기 때문에, **물리 계층 전반에 걸쳐 신뢰성 있는 데이터 전달을 제공**하는 계층이다.
    > 
    
    💡 네트워크 위의 개체들 간의 데이터를 전송하고 물리 계층에서의 오류를 찾아내고 수정한다. 가장 유명한 예시로는 **이더넷**이 있다.
    
    
- **3레벨 : 네트워크 계층**
    
    > 네트워크에서 다른 머신으로의 연결을 관리한다. 여러 개의 노드를 거칠 때마다 경로를 찾아준다.
    > 
    
    💡 라우터가 이 계층에서 동작한다. 잘 알려진 인터넷이 바로 네트워크 계층에 속한다.
    
    
- **4레벨 : 전송 계층**
    
    > 네트워크 양 끝단의 사용자들이 **오류가 없는 데이터를 주고받을 수 있도록 보장**해준다.
    > 
    
    💡 전송 계층 덕분에 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않을 수 있다. 4레벨에서 사용하는 **프로토콜 중 가장 잘 알려진 예는 TCP**이다.
    
    
- **5레벨 : 세션 계층 Session Layer**
    
    > 애플리케이션 사이의 연결을 관리한다.
    > 
- **6레벨 : 표현 계층 Presentation Layer**
    
    > 코드간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다.
    > 
- **7레벨 : 응용 계층 Application Layer**
    
    > 네트워크를 사용하는 애플리케이션을 구성한다.
    > 

<br>

**네트워크 계층 모델 : TCP/IP 4계층**
---

> TCP/IP 프로토콜은 4계층으로 나누어 설명할 수 있다.
> 

[참고 : 11. 소켓 프로그래밍 기초](https://jihooyim1.gitbooks.io/unixbasic/content/contents/11.html)

💡 TCP/IP 계층구조를 구성하는 다양한 프로토콜 중에서 **전송 계층의 TCP 프로토콜**과 **네트워크 계층의 IP 프로토콜이 대표적**이기에 TCP/IP프로토콜이라 불린다.

<p align = 'center'>
<img src = "https://user-images.githubusercontent.com/93521799/146640066-ef38fbfa-1309-47c7-b9ad-aceb2066ac13.png" width = "500">
</p>
<p align = 'center'>
<em></em>
</p>

- **Network access layer 와 Hardware layer**
    
    > **물리적인 네트워크와의 연결을 담당**하는 계층
    > 
    
    일반적으로 이더넷 카드나 랜카드라고 부르는 부분이 이 계층에 속한다.
    
- **Network layer**
    
    > 인터넷 계층이라고도 하며, **패킷이 전달되는 경로를 담당**한다.
    > 
    
    통상 TCP/IP라고 부르는 프로토콜에서 **IP(Internet Protocol)가 이 계층에 속한 프로토콜**이다. 이 계층에는 ICMP, ARP도 있다.
    
- **Transport layer**
    
    > 패킷의 전송을 담당하는 계층.
    > 
    
    **TCP(Transmission Control Protocol)** 와 UDP(User Datagram Protocol)가 있다.
    
- **Application layer**
    
    > 사용자에게 서비스를 제공하기 위한 계층.
    > 

<br>

**네트워크의 실제 예**
===

**DMA(Direct Memory Access)**
---

**CPU의 개입 없이** I/O 장치와 메모리 사이의 데이터를 전송하는 방식. 프로그램 수행 중의 인터럽트의 발생 횟수를 최소화한다. 컴퓨터 내부의 버스 bus가 지원하는 기능이다.

네트워크는 DMA 기능을 통해 CPU의 개입 없이 메모리에 접근할 수 있다.

<br>

**LAN(Local Area Network)**
---
수 km 범위 이내의 국지적인 지역에 한정된 네트워크.

<br>

**WAN(Wide Area Network)**
---
먼 거리에 있는 근거리 통신망이나 도시권 통신망으로 데이터를 전송하는데 쓰이는 네트워크


<br>

**네트워크의 하위 수준 : 이더넷 세그먼트 Ethernet Segment**
---


> **허브**에 여러 **호스트들**이 **전선**으로 연결된다. 한 방이나 건물의 한 층을 관리할 수 있다.
> 

<p align = 'center'>
<img src = "https://user-images.githubusercontent.com/93521799/146636952-567c718e-5512-44e1-8398-d415662b0afe.png" width = "350">
</p>
<p align = 'center'>
<em>이더넷 세그먼트.</em>
</p>



**작동**

- 각각의 이더넷 어댑터들은 고유한 48비트의 MAC 주소(물리적 주소)를 가진다(예. 00:16:ea:e3:54:e6).
- 호스트는 **프레임**이라 부르는 비트들을 세그먼트의 다른 주소에 보낼 수 있다.
    - 프레임은 한 로컬 네트워크 안에서만 돌아다닌다.
    - 프레임은 헤더 비트와 데이터 비트로 나눠진다.
    - 헤더 비트에는 프레임의 소스와 대상, 프레임의 길이가 들어 있다.
- **허브는 각 포트에서 수신한 모든 비트를 다른 모든 포트로 복사하는 역할**을 한다. 따라서 모든 호스트는 허브에서 돌아다니는 모든 비트를 다 볼 수 있다.

<br>

**다음 수준 : 브릿지형 이더넷 Bridged Ethernet Segment**
---

> 다수의 세그먼트들이 전선들과 **브릿지**를 통해 연결된, **세그먼트보다 더 큰 LAN**이다. 빌딩 전체나 캠퍼스 전체를 관리할 수 있다.
> 

<p align = 'center'>
<img src = "https://user-images.githubusercontent.com/93521799/146636954-378f5588-87a8-4fea-959a-9c46aca804e1.png" width = "350">
</p>
<p align = 'center'>
<em>브릿지로 연결된 이더넷 세그먼트</em>
</p>



**작동**

- 브릿지는 허브보다 더 높은 전선의 대역폭을 가진다.
- 브릿지는 학습을 통해 **선택적으로** 하나의 포트에서 다른 포트로 프레임을 복사한다**(허브랑 다르다!)**.

<br>

**그 다음 수준 : 인터넷 internets**
---

> 비호환성(국지적) LAN들을 **라우터**라는 특별한 컴퓨터를 통해 물리적으로 연결할 수 있다. 이렇게 **복수의 네트워크를 집합시킨 광역 네트워크를 인터넷**이라 한다.
> 

💡 라우터는 데이터를 수신할 주소에 따른 특정한 프로토콜을 따른다.

<p align = 'center'>
<img src = "https://user-images.githubusercontent.com/93521799/146636956-80d94803-0f7b-4ec4-a527-a74cd356e2c8.png" width = "350">
</p>
<p align = 'center'>
<em>인터넷 : 서로 호환이 불가능한 국지적인 네트워크를 연결시켰다.</em>
</p>



- **라우팅**
    
    패킷 안의 정보들을 이용해 **데이터를 전달하는 경로를 선택**하는 과정. 라우터는 이 과정을 능동적으로 해 주는 장치를 의미한다.
    
- 논리적으로 봤을 때, 한 호스트에서 다른 호스트까지 패킷(데이터)을 보낼 때 그 데이터는 여러 라우터들을 건너 뛰어 간다.

<br>

**인터넷 프로토콜**
---

> 어떻게 서로 다른 네트워크(LAN과 WAN)를 거쳐서 데이터를 대상 호스트로 보낼 수 있을까? 각 네트워크는 컴퓨터, 국가, 위치, 사용자 등 모든 것이 다른데.
> 

💡 **프로토콜 소프트웨어**가 각 호스트와 라우터에서 돌아간다. 이 프로토콜은 호스트와 라우터들이 **네트워크 간에 데이터를 보낼 때 어떻게 협력해야 하는지**를 결정해준다.

<br>

**역할**

> 즉 **인터넷 프로토콜은 각 네트워크 간의 격차를 줄여주는 역할**을 한다. 이를 위해 두 가지 기능을 제공한다.
> 
- **명명법**
    
    > 각 호스트마다 유일한 호스트 주소를 정해준다.
    > 
- **전달 기법**
    
    > 전달되는 모든 데이터는 **패킷 단위**로 전달된다. 패킷은 패킷 크기, 소스, 대상을 포함한 **헤더**와 **데이터**로 구성된다.
    > 
    
    💡 **패킷**이 L3 계층, **네트워크 단위**에서 전송되는 데이터라면, **프레임**은 L2 계층 안에서, 즉 **동일 네트워크 안에서만** 전송된다.
    
<br>

**캡슐화**
---

<p align = 'center'>
<img src = "https://user-images.githubusercontent.com/93521799/146636959-7586be0e-0013-45a4-8666-33c7325950af.png" width = "550">
</p>
<p align = 'center'>
<em>호스트 A에서 다른 LAN의 호스트 B로 데이터를 전송하는 과정.</em>
</p>



- **호스트 A의 클라이언트**
- **호스트 A의 프로토콜 소프트웨어**
    - 인터넷 라우팅에 사용할 패킷 헤더를 추가해 **internet 패킷**을 만든다. 패킷 헤더에는 **호스트 B로** 주소가 지정된다.
    - 그 앞에 로컬 라우팅에 사용할 프레임 헤더를 추가해 **LAN1 프레임**을 만든다. 프레임 헤더는 **라우터로** 주소가 지정된다.
    - LAN1 프레임에서의 데이터 안에 internet 패킷이 들어있다.
- **호스트 A의 LAN 1 어댑터**
    - 해당 프레임을 네트워크로 복사한다.
- **라우터의 LAN 1 어댑터**
    - 해당 프레임을 라우터의 프로토콜 소프트웨어로 전달한다.
- **라우터**
    - **internet 패킷 헤더**에서 목적지의 internet 주소를 가져와 LAN2의 라우팅 테이블에서 패킷의 목적지인 호스트 B를 찾는다.
    - LAN 1 프레임 헤더를 벗겨내고 **LAN 2 프레임 헤더(호스트 B의 주소)를 추가**한다.
- **라우터의 LAN 2 어댑터**
    - 해당 프레임을 네트워크로 복사한다.
- **호스트 B의 LAN 2 어댑터**
    - 해당 프레임을 읽어서 프로토콜 소프트웨어로 옮긴다.
- **호스트 B의 프로토콜 소프트웨어**
    - 패킷 헤더와 프레임 헤더를 벗겨내어 데이터를 읽어낸다.